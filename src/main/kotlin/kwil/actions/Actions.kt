// This file is generated by the generator. Do not edit it manually.
// check github.com/idos-networks/idos-schema

package org.idos.kwil.actions
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import org.idos.kwil.utils.SchemaField
import org.idos.kwil.utils.DataType
import org.idos.kwil.KwilActionClient


object ActionSchema {
    val schemas =
        mapOf(
"add_inserter_as_owner" to listOf(
SchemaField("id", DataType.Uuid),
SchemaField("name", DataType.Text),
),
"delete_inserter_as_owner" to listOf(
SchemaField("id", DataType.Uuid),
),
"add_delegate_as_owner" to listOf(
SchemaField("address", DataType.Text),
SchemaField("inserter_id", DataType.Uuid),
),
"delete_delegate_as_owner" to listOf(
SchemaField("address", DataType.Text),
),
"get_inserter" to listOf(
),
"get_inserter_or_null" to listOf(
),
"add_user_as_inserter" to listOf(
SchemaField("id", DataType.Uuid),
SchemaField("recipient_encryption_public_key", DataType.Text),
SchemaField("encryption_password_store", DataType.Text),
),
"update_user_pub_key_as_inserter" to listOf(
SchemaField("id", DataType.Uuid),
SchemaField("recipient_encryption_public_key", DataType.Text),
SchemaField("encryption_password_store", DataType.Text),
),
"get_user" to listOf(
),
"get_user_as_inserter" to listOf(
SchemaField("id", DataType.Uuid),
),
"upsert_wallet_as_inserter" to listOf(
SchemaField("id", DataType.Uuid),
SchemaField("user_id", DataType.Uuid),
SchemaField("address", DataType.Text),
SchemaField("public_key", DataType.Text),
SchemaField("wallet_type", DataType.Text),
SchemaField("message", DataType.Text),
SchemaField("signature", DataType.Text),
),
"add_wallet" to listOf(
SchemaField("id", DataType.Uuid),
SchemaField("address", DataType.Text),
SchemaField("public_key", DataType.Text),
SchemaField("message", DataType.Text),
SchemaField("signature", DataType.Text),
),
"get_wallets" to listOf(
),
"remove_wallet" to listOf(
SchemaField("id", DataType.Uuid),
),
"upsert_credential_as_inserter" to listOf(
SchemaField("id", DataType.Uuid),
SchemaField("user_id", DataType.Uuid),
SchemaField("issuer_auth_public_key", DataType.Text),
SchemaField("encryptor_public_key", DataType.Text),
SchemaField("content", DataType.Text),
SchemaField("public_notes", DataType.Text),
SchemaField("public_notes_signature", DataType.Text),
SchemaField("broader_signature", DataType.Text),
),
"add_credential" to listOf(
SchemaField("id", DataType.Uuid),
SchemaField("issuer_auth_public_key", DataType.Text),
SchemaField("encryptor_public_key", DataType.Text),
SchemaField("content", DataType.Text),
SchemaField("public_notes", DataType.Text),
SchemaField("public_notes_signature", DataType.Text),
SchemaField("broader_signature", DataType.Text),
),
"get_credentials" to listOf(
),
"get_credentials_shared_by_user" to listOf(
SchemaField("user_id", DataType.Uuid),
SchemaField("issuer_auth_public_key", DataType.Text),
),
"edit_credential" to listOf(
SchemaField("id", DataType.Uuid),
SchemaField("public_notes", DataType.Text),
SchemaField("public_notes_signature", DataType.Text),
SchemaField("broader_signature", DataType.Text),
SchemaField("content", DataType.Text),
SchemaField("encryptor_public_key", DataType.Text),
SchemaField("issuer_auth_public_key", DataType.Text),
),
"edit_public_notes_as_issuer" to listOf(
SchemaField("public_notes_id", DataType.Text),
SchemaField("public_notes", DataType.Text),
),
"remove_credential" to listOf(
SchemaField("id", DataType.Uuid),
),
"share_credential" to listOf(
SchemaField("id", DataType.Uuid),
SchemaField("original_credential_id", DataType.Uuid),
SchemaField("public_notes", DataType.Text),
SchemaField("public_notes_signature", DataType.Text),
SchemaField("broader_signature", DataType.Text),
SchemaField("content", DataType.Text),
SchemaField("content_hash", DataType.Text),
SchemaField("encryptor_public_key", DataType.Text),
SchemaField("issuer_auth_public_key", DataType.Text),
SchemaField("grantee_wallet_identifier", DataType.Text),
SchemaField("locked_until", DataType.Int),
),
"create_credential_copy" to listOf(
SchemaField("id", DataType.Uuid),
SchemaField("original_credential_id", DataType.Uuid),
SchemaField("public_notes", DataType.Text),
SchemaField("public_notes_signature", DataType.Text),
SchemaField("broader_signature", DataType.Text),
SchemaField("content", DataType.Text),
SchemaField("encryptor_public_key", DataType.Text),
SchemaField("issuer_auth_public_key", DataType.Text),
),
"share_credential_through_dag" to listOf(
SchemaField("id", DataType.Uuid),
SchemaField("user_id", DataType.Uuid),
SchemaField("issuer_auth_public_key", DataType.Text),
SchemaField("encryptor_public_key", DataType.Text),
SchemaField("content", DataType.Text),
SchemaField("content_hash", DataType.Text),
SchemaField("public_notes", DataType.Text),
SchemaField("public_notes_signature", DataType.Text),
SchemaField("broader_signature", DataType.Text),
SchemaField("original_credential_id", DataType.Uuid),
SchemaField("dag_owner_wallet_identifier", DataType.Text),
SchemaField("dag_grantee_wallet_identifier", DataType.Text),
SchemaField("dag_locked_until", DataType.Int),
SchemaField("dag_signature", DataType.Text),
),
"create_credentials_by_dwg" to listOf(
SchemaField("issuer_auth_public_key", DataType.Text),
SchemaField("original_encryptor_public_key", DataType.Text),
SchemaField("original_credential_id", DataType.Uuid),
SchemaField("original_content", DataType.Text),
SchemaField("original_public_notes", DataType.Text),
SchemaField("original_public_notes_signature", DataType.Text),
SchemaField("original_broader_signature", DataType.Text),
SchemaField("copy_encryptor_public_key", DataType.Text),
SchemaField("copy_credential_id", DataType.Uuid),
SchemaField("copy_content", DataType.Text),
SchemaField("copy_public_notes_signature", DataType.Text),
SchemaField("copy_broader_signature", DataType.Text),
SchemaField("content_hash", DataType.Text),
SchemaField("dwg_owner", DataType.Text),
SchemaField("dwg_grantee", DataType.Text),
SchemaField("dwg_issuer_public_key", DataType.Text),
SchemaField("dwg_id", DataType.Uuid),
SchemaField("dwg_access_grant_timelock", DataType.Text),
SchemaField("dwg_not_before", DataType.Text),
SchemaField("dwg_not_after", DataType.Text),
SchemaField("dwg_signature", DataType.Text),
),
"credential_exist_as_inserter" to listOf(
SchemaField("id", DataType.Uuid),
),
"get_credential_owned" to listOf(
SchemaField("id", DataType.Uuid),
),
"get_credential_shared" to listOf(
SchemaField("id", DataType.Uuid),
),
"get_sibling_credential_id" to listOf(
SchemaField("content_hash", DataType.Text),
),
"credential_belongs_to_caller" to listOf(
SchemaField("id", DataType.Uuid),
),
"credential_exist" to listOf(
SchemaField("id", DataType.Uuid),
),
"add_attribute_as_inserter" to listOf(
SchemaField("id", DataType.Uuid),
SchemaField("user_id", DataType.Uuid),
SchemaField("attribute_key", DataType.Text),
SchemaField("value", DataType.Text),
),
"add_attribute" to listOf(
SchemaField("id", DataType.Uuid),
SchemaField("attribute_key", DataType.Text),
SchemaField("value", DataType.Text),
),
"get_attributes" to listOf(
),
"edit_attribute" to listOf(
SchemaField("id", DataType.Uuid),
SchemaField("attribute_key", DataType.Text),
SchemaField("value", DataType.Text),
),
"remove_attribute" to listOf(
SchemaField("id", DataType.Uuid),
),
"share_attribute" to listOf(
SchemaField("id", DataType.Uuid),
SchemaField("original_attribute_id", DataType.Uuid),
SchemaField("attribute_key", DataType.Text),
SchemaField("value", DataType.Text),
),
"dwg_message" to listOf(
SchemaField("owner_wallet_identifier", DataType.Text),
SchemaField("grantee_wallet_identifier", DataType.Text),
SchemaField("issuer_public_key", DataType.Text),
SchemaField("id", DataType.Uuid),
SchemaField("access_grant_timelock", DataType.Text),
SchemaField("not_usable_before", DataType.Text),
SchemaField("not_usable_after", DataType.Text),
),
"revoke_access_grant" to listOf(
SchemaField("id", DataType.Uuid),
),
"get_access_grants_owned" to listOf(
),
"get_access_grants_granted" to listOf(
SchemaField("user_id", DataType.Uuid),
SchemaField("page", DataType.Int),
SchemaField("size", DataType.Int),
),
"get_access_grants_granted_count" to listOf(
SchemaField("user_id", DataType.Uuid),
),
"has_locked_access_grants" to listOf(
SchemaField("id", DataType.Uuid),
),
"dag_message" to listOf(
SchemaField("dag_owner_wallet_identifier", DataType.Text),
SchemaField("dag_grantee_wallet_identifier", DataType.Text),
SchemaField("dag_data_id", DataType.Uuid),
SchemaField("dag_locked_until", DataType.Int),
SchemaField("dag_content_hash", DataType.Text),
),
"create_ag_by_dag_for_copy" to listOf(
SchemaField("dag_owner_wallet_identifier", DataType.Text),
SchemaField("dag_grantee_wallet_identifier", DataType.Text),
SchemaField("dag_data_id", DataType.Uuid),
SchemaField("dag_locked_until", DataType.Int),
SchemaField("dag_content_hash", DataType.Text),
SchemaField("dag_signature", DataType.Text),
),
"create_access_grant" to listOf(
SchemaField("grantee_wallet_identifier", DataType.Text),
SchemaField("data_id", DataType.Uuid),
SchemaField("locked_until", DataType.Int),
SchemaField("content_hash", DataType.Text),
SchemaField("inserter_type", DataType.Text),
SchemaField("inserter_id", DataType.Text),
),
"get_access_grants_for_credential" to listOf(
SchemaField("credential_id", DataType.Uuid),
),
"has_profile" to listOf(
SchemaField("address", DataType.Text),
),
"add_passporting_club_as_owner" to listOf(
SchemaField("id", DataType.Uuid),
SchemaField("name", DataType.Text),
),
"delete_passporting_club_as_owner" to listOf(
SchemaField("id", DataType.Uuid),
),
"add_passporting_peer_as_owner" to listOf(
SchemaField("id", DataType.Uuid),
SchemaField("name", DataType.Text),
SchemaField("issuer_public_key", DataType.Text),
SchemaField("passporting_server_url_base", DataType.Text),
),
"delete_passporting_peer_as_owner" to listOf(
SchemaField("id", DataType.Uuid),
),
"update_passporting_peer_as_owner" to listOf(
SchemaField("id", DataType.Uuid),
SchemaField("name", DataType.Text),
SchemaField("issuer_public_key", DataType.Text),
SchemaField("passporting_server_url_base", DataType.Text),
),
"add_peer_to_club_as_owner" to listOf(
SchemaField("passporting_club_id", DataType.Uuid),
SchemaField("passporting_peer_id", DataType.Uuid),
),
"delete_peer_from_club_as_owner" to listOf(
SchemaField("passporting_club_id", DataType.Uuid),
SchemaField("passporting_peer_id", DataType.Uuid),
),
"get_passporting_peers" to listOf(
),
)
fun getSchema(actionName: String): List<SchemaField>? = schemas[actionName]
}

//  INSERTER AND DELEGATE ACTIONS

suspend fun addInserterAsOwner(client: KwilActionClient,
id: String,
name: String): String? {
    return client.executeAction("add_inserter_as_owner", mapOf(
      "id" to id,
    "name" to name
    ), "Add inserter as owner", true);
}

suspend fun deleteInserterAsOwner(client: KwilActionClient,
id: String): String? {
    return client.executeAction("delete_inserter_as_owner", mapOf(
      "id" to id
    ), "Delete inserter as owner", true);
}

suspend fun addDelegateAsOwner(client: KwilActionClient,
address: String,
inserterId: String): String? {
    return client.executeAction("add_delegate_as_owner", mapOf(
      "address" to address,
    "inserter_id" to inserterId
    ), "Add a delegate as owner", true);
}

suspend fun deleteDelegateAsOwner(client: KwilActionClient,
address: String): String? {
    return client.executeAction("delete_delegate_as_owner", mapOf(
      "address" to address
    ), "Delete a delegate from idOS", true);
}

@Serializable
data class GetInserterResponse(
  val name: String
)

suspend fun getInserter(client: KwilActionClient): GetInserterResponse {
  return client.callAction<GetInserterResponse>("get_inserter", mapOf(
    
  )).first()
}

@Serializable
data class GetInserterOrNullResponse(
  val name: String
)

suspend fun getInserterOrNull(client: KwilActionClient): GetInserterOrNullResponse {
  return client.callAction<GetInserterOrNullResponse>("get_inserter_or_null", mapOf(
    
  )).first()
}
//  USER ACTIONS

suspend fun addUserAsInserter(client: KwilActionClient,
id: String,
recipientEncryptionPublicKey: String,
encryptionPasswordStore: String): String? {
    return client.executeAction("add_user_as_inserter", mapOf(
      "id" to id,
    "recipient_encryption_public_key" to recipientEncryptionPublicKey,
    "encryption_password_store" to encryptionPasswordStore
    ), "Add a user to idOS", true);
}

suspend fun updateUserPubKeyAsInserter(client: KwilActionClient,
id: String,
recipientEncryptionPublicKey: String,
encryptionPasswordStore: String): String? {
    return client.executeAction("update_user_pub_key_as_inserter", mapOf(
      "id" to id,
    "recipient_encryption_public_key" to recipientEncryptionPublicKey,
    "encryption_password_store" to encryptionPasswordStore
    ), "Update user's encryption key and password store in idOS", true);
}

@Serializable
data class GetUserResponse(
  val id: String,
  @SerialName("recipient_encryption_public_key")
  val recipientEncryptionPublicKey: String,
  @SerialName("encryption_password_store")
  val encryptionPasswordStore: String
)

suspend fun getUser(client: KwilActionClient): GetUserResponse {
  return client.callAction<GetUserResponse>("get_user", mapOf(
    
  )).first()
}

@Serializable
data class GetUserAsInserterResponse(
  val id: String,
  @SerialName("recipient_encryption_public_key")
  val recipientEncryptionPublicKey: String,
  @SerialName("encryption_password_store")
  val encryptionPasswordStore: String,
  val inserter: String
)

suspend fun getUserAsInserter(client: KwilActionClient,
id: String): GetUserAsInserterResponse {
  return client.callAction<GetUserAsInserterResponse>("get_user_as_inserter", mapOf(
    "id" to id
  )).first()
}
//  WALLET ACTIONS

suspend fun upsertWalletAsInserter(client: KwilActionClient,
id: String,
userId: String,
address: String,
publicKey: String,
walletType: String,
message: String,
signature: String): String? {
    return client.executeAction("upsert_wallet_as_inserter", mapOf(
      "id" to id,
    "user_id" to userId,
    "address" to address,
    "public_key" to publicKey,
    "wallet_type" to walletType,
    "message" to message,
    "signature" to signature
    ), "Add a wallet to idOS", true);
}

suspend fun addWallet(client: KwilActionClient,
id: String,
address: String,
publicKey: String,
message: String,
signature: String): String? {
    return client.executeAction("add_wallet", mapOf(
      "id" to id,
    "address" to address,
    "public_key" to publicKey,
    "message" to message,
    "signature" to signature
    ), "Add a wallet to idOS", true);
}

@Serializable
data class GetWalletsResponse(
  val id: String,
  @SerialName("user_id")
  val userId: String,
  val address: String,
  @SerialName("public_key")
  val publicKey: String,
  @SerialName("wallet_type")
  val walletType: String,
  val message: String,
  val signature: String,
  val inserter: String
)

suspend fun getWallets(client: KwilActionClient): List<GetWalletsResponse> {
  return client.callAction<GetWalletsResponse>("get_wallets", mapOf(
    
  ))
}

suspend fun removeWallet(client: KwilActionClient,
id: String): String? {
    return client.executeAction("remove_wallet", mapOf(
      "id" to id
    ), "Remove a wallet from idOS", true);
}
//  CREDENTIAL ACTIONS
//  throw an error if not authorized

suspend fun upsertCredentialAsInserter(client: KwilActionClient,
id: String,
userId: String,
issuerAuthPublicKey: String,
encryptorPublicKey: String,
content: String,
publicNotes: String,
publicNotesSignature: String,
broaderSignature: String): String? {
    return client.executeAction("upsert_credential_as_inserter", mapOf(
      "id" to id,
    "user_id" to userId,
    "issuer_auth_public_key" to issuerAuthPublicKey,
    "encryptor_public_key" to encryptorPublicKey,
    "content" to content,
    "public_notes" to publicNotes,
    "public_notes_signature" to publicNotesSignature,
    "broader_signature" to broaderSignature
    ), "Add or update a credential in idOS on behalf of a user", true);
}

suspend fun addCredential(client: KwilActionClient,
id: String,
issuerAuthPublicKey: String,
encryptorPublicKey: String,
content: String,
publicNotes: String,
publicNotesSignature: String,
broaderSignature: String): String? {
    return client.executeAction("add_credential", mapOf(
      "id" to id,
    "issuer_auth_public_key" to issuerAuthPublicKey,
    "encryptor_public_key" to encryptorPublicKey,
    "content" to content,
    "public_notes" to publicNotes,
    "public_notes_signature" to publicNotesSignature,
    "broader_signature" to broaderSignature
    ), "Add a new credential", true);
}

@Serializable
data class GetCredentialsResponse(
  val id: String,
  @SerialName("user_id")
  val userId: String,
  @SerialName("public_notes")
  val publicNotes: String,
  @SerialName("issuer_auth_public_key")
  val issuerAuthPublicKey: String,
  val inserter: String?,
  @SerialName("original_id")
  val originalId: String?
)

suspend fun getCredentials(client: KwilActionClient): List<GetCredentialsResponse> {
  return client.callAction<GetCredentialsResponse>("get_credentials", mapOf(
    
  ))
}

@Serializable
data class GetCredentialsSharedByUserResponse(
  val id: String,
  @SerialName("user_id")
  val userId: String,
  @SerialName("public_notes")
  val publicNotes: String,
  @SerialName("encryptor_public_key")
  val encryptorPublicKey: String,
  @SerialName("issuer_auth_public_key")
  val issuerAuthPublicKey: String,
  val inserter: String,
  @SerialName("original_id")
  val originalId: String
)

suspend fun getCredentialsSharedByUser(client: KwilActionClient,
userId: String,
issuerAuthPublicKey: String?): List<GetCredentialsSharedByUserResponse> {
  return client.callAction<GetCredentialsSharedByUserResponse>("get_credentials_shared_by_user", mapOf(
    "user_id" to userId,
    "issuer_auth_public_key" to issuerAuthPublicKey
  ))
}
//  we forbid to edit a copy
//  only copies can have AGs, so data_id in AGs is id of a copy
//  if $id is shared_credentials.copy_id - it is a copy

suspend fun editCredential(client: KwilActionClient,
id: String,
publicNotes: String,
publicNotesSignature: String,
broaderSignature: String,
content: String,
encryptorPublicKey: String,
issuerAuthPublicKey: String): String? {
    return client.executeAction("edit_credential", mapOf(
      "id" to id,
    "public_notes" to publicNotes,
    "public_notes_signature" to publicNotesSignature,
    "broader_signature" to broaderSignature,
    "content" to content,
    "encryptor_public_key" to encryptorPublicKey,
    "issuer_auth_public_key" to issuerAuthPublicKey
    ), "Edit a credential", true);
}
//  Be aware that @caller here is ed25519 public key, hex encoded.
//  All other @caller in the schema are either secp256k1 or nep413
//  This action can't be called by kwil-cli (as kwil-cli uses secp256k1 only)

suspend fun editPublicNotesAsIssuer(client: KwilActionClient,
publicNotesId: String,
publicNotes: String): String? {
    return client.executeAction("edit_public_notes_as_issuer", mapOf(
      "public_notes_id" to publicNotesId,
    "public_notes" to publicNotes
    ), "Edit a credential in your idOS profile", true);
}

suspend fun removeCredential(client: KwilActionClient,
id: String): String? {
    return client.executeAction("remove_credential", mapOf(
      "id" to id
    ), "Remove a credential from your idOS profile", true);
}

suspend fun shareCredential(client: KwilActionClient,
id: String,
originalCredentialId: String,
publicNotes: String,
publicNotesSignature: String,
broaderSignature: String,
content: String,
contentHash: String,
encryptorPublicKey: String,
issuerAuthPublicKey: String,
granteeWalletIdentifier: String,
lockedUntil: Int): String? {
    return client.executeAction("share_credential", mapOf(
      "id" to id,
    "original_credential_id" to originalCredentialId,
    "public_notes" to publicNotes,
    "public_notes_signature" to publicNotesSignature,
    "broader_signature" to broaderSignature,
    "content" to content,
    "content_hash" to contentHash,
    "encryptor_public_key" to encryptorPublicKey,
    "issuer_auth_public_key" to issuerAuthPublicKey,
    "grantee_wallet_identifier" to granteeWalletIdentifier,
    "locked_until" to lockedUntil
    ), "Share a credential with another idOS user", true);
}
//  Passporting scenario

suspend fun createCredentialCopy(client: KwilActionClient,
id: String,
originalCredentialId: String,
publicNotes: String,
publicNotesSignature: String,
broaderSignature: String,
content: String,
encryptorPublicKey: String,
issuerAuthPublicKey: String): String? {
    return client.executeAction("create_credential_copy", mapOf(
      "id" to id,
    "original_credential_id" to originalCredentialId,
    "public_notes" to publicNotes,
    "public_notes_signature" to publicNotesSignature,
    "broader_signature" to broaderSignature,
    "content" to content,
    "encryptor_public_key" to encryptorPublicKey,
    "issuer_auth_public_key" to issuerAuthPublicKey
    ), "Share a credential with another user on idOS", true);
}
//  It can be used with EVM-compatible signatures only
//  This works for EVM-compatible signatures only

suspend fun shareCredentialThroughDag(client: KwilActionClient,
id: String,
userId: String,
issuerAuthPublicKey: String,
encryptorPublicKey: String,
content: String,
contentHash: String,
publicNotes: String,
publicNotesSignature: String,
broaderSignature: String,
originalCredentialId: String,
dagOwnerWalletIdentifier: String,
dagGranteeWalletIdentifier: String,
dagLockedUntil: Int,
dagSignature: String): String? {
    return client.executeAction("share_credential_through_dag", mapOf(
      "id" to id,
    "user_id" to userId,
    "issuer_auth_public_key" to issuerAuthPublicKey,
    "encryptor_public_key" to encryptorPublicKey,
    "content" to content,
    "content_hash" to contentHash,
    "public_notes" to publicNotes,
    "public_notes_signature" to publicNotesSignature,
    "broader_signature" to broaderSignature,
    "original_credential_id" to originalCredentialId,
    "dag_owner_wallet_identifier" to dagOwnerWalletIdentifier,
    "dag_grantee_wallet_identifier" to dagGranteeWalletIdentifier,
    "dag_locked_until" to dagLockedUntil,
    "dag_signature" to dagSignature
    ), "Share a credential through the DAG", true);
}
//  For access grant
//  Check the content creator (encryptor) is the issuer that user delegated to issue the credential
//  Get the wallet type and public key for XRPL/NEAR wallets from database
//  Will fail if not in the RFC3339 format
//  Check the format and precedence
//  Check if current block timestamp in time range allowed by write grant.
//  @block_timestamp is a timestamp of previous block, which is can be a few seconds earlier
//  (max is 6 seconds in current network consensus settings) then a time on a requester's machine.
//  Also, if requester's machine has wrong time, it can be an issue.
//  Insert original credential
//  Insert copy credential

suspend fun createCredentialsByDwg(client: KwilActionClient,
issuerAuthPublicKey: String,
originalEncryptorPublicKey: String,
originalCredentialId: String,
originalContent: String,
originalPublicNotes: String,
originalPublicNotesSignature: String,
originalBroaderSignature: String,
copyEncryptorPublicKey: String,
copyCredentialId: String,
copyContent: String,
copyPublicNotesSignature: String,
copyBroaderSignature: String,
contentHash: String,
dwgOwner: String,
dwgGrantee: String,
dwgIssuerPublicKey: String,
dwgId: String,
dwgAccessGrantTimelock: String,
dwgNotBefore: String,
dwgNotAfter: String,
dwgSignature: String): String? {
    return client.executeAction("create_credentials_by_dwg", mapOf(
      "issuer_auth_public_key" to issuerAuthPublicKey,
    "original_encryptor_public_key" to originalEncryptorPublicKey,
    "original_credential_id" to originalCredentialId,
    "original_content" to originalContent,
    "original_public_notes" to originalPublicNotes,
    "original_public_notes_signature" to originalPublicNotesSignature,
    "original_broader_signature" to originalBroaderSignature,
    "copy_encryptor_public_key" to copyEncryptorPublicKey,
    "copy_credential_id" to copyCredentialId,
    "copy_content" to copyContent,
    "copy_public_notes_signature" to copyPublicNotesSignature,
    "copy_broader_signature" to copyBroaderSignature,
    "content_hash" to contentHash,
    "dwg_owner" to dwgOwner,
    "dwg_grantee" to dwgGrantee,
    "dwg_issuer_public_key" to dwgIssuerPublicKey,
    "dwg_id" to dwgId,
    "dwg_access_grant_timelock" to dwgAccessGrantTimelock,
    "dwg_not_before" to dwgNotBefore,
    "dwg_not_after" to dwgNotAfter,
    "dwg_signature" to dwgSignature
    ), "Create a new credential in your idOS profile", true);
}

@Serializable
data class CredentialExistAsInserterResponse(
  @SerialName("credential_exist")
  val credentialExist: Boolean
)

suspend fun credentialExistAsInserter(client: KwilActionClient,
id: String): CredentialExistAsInserterResponse {
  return client.callAction<CredentialExistAsInserterResponse>("credential_exist_as_inserter", mapOf(
    "id" to id
  )).first()
}

@Serializable
data class GetCredentialOwnedResponse(
  val id: String,
  @SerialName("user_id")
  val userId: String,
  @SerialName("public_notes")
  val publicNotes: String,
  val content: String,
  @SerialName("encryptor_public_key")
  val encryptorPublicKey: String,
  @SerialName("issuer_auth_public_key")
  val issuerAuthPublicKey: String,
  val inserter: String
)

suspend fun getCredentialOwned(client: KwilActionClient,
id: String): List<GetCredentialOwnedResponse> {
  return client.callAction<GetCredentialOwnedResponse>("get_credential_owned", mapOf(
    "id" to id
  ))
}
//  As a credential copy doesn't contain PUBLIC notes, we return respective original credential PUBLIC notes

@Serializable
data class GetCredentialSharedResponse(
  val id: String,
  @SerialName("user_id")
  val userId: String,
  @SerialName("public_notes")
  val publicNotes: String,
  val content: String,
  @SerialName("encryptor_public_key")
  val encryptorPublicKey: String,
  @SerialName("issuer_auth_public_key")
  val issuerAuthPublicKey: String,
  val inserter: String
)

suspend fun getCredentialShared(client: KwilActionClient,
id: String): List<GetCredentialSharedResponse> {
  return client.callAction<GetCredentialSharedResponse>("get_credential_shared", mapOf(
    "id" to id
  ))
}

@Serializable
data class GetSiblingCredentialIdResponse(
  val id: String
)

suspend fun getSiblingCredentialId(client: KwilActionClient,
contentHash: String): GetSiblingCredentialIdResponse {
  return client.callAction<GetSiblingCredentialIdResponse>("get_sibling_credential_id", mapOf(
    "content_hash" to contentHash
  )).first()
}

@Serializable
data class CredentialBelongsToCallerResponse(
  val belongs: Boolean
)

suspend fun credentialBelongsToCaller(client: KwilActionClient,
id: String): CredentialBelongsToCallerResponse {
  return client.callAction<CredentialBelongsToCallerResponse>("credential_belongs_to_caller", mapOf(
    "id" to id
  )).first()
}

@Serializable
data class CredentialExistResponse(
  @SerialName("credential_exist")
  val credentialExist: Boolean
)

suspend fun credentialExist(client: KwilActionClient,
id: String): CredentialExistResponse {
  return client.callAction<CredentialExistResponse>("credential_exist", mapOf(
    "id" to id
  )).first()
}
//  ATTRIBUTE ACTIONS

suspend fun addAttributeAsInserter(client: KwilActionClient,
id: String,
userId: String,
attributeKey: String,
value: String): String? {
    return client.executeAction("add_attribute_as_inserter", mapOf(
      "id" to id,
    "user_id" to userId,
    "attribute_key" to attributeKey,
    "value" to value
    ), "Add a new attribute as inserter", true);
}

suspend fun addAttribute(client: KwilActionClient,
id: String,
attributeKey: String,
value: String): String? {
    return client.executeAction("add_attribute", mapOf(
      "id" to id,
    "attribute_key" to attributeKey,
    "value" to value
    ), "Create a new attribute in your idOS profile", true);
}

@Serializable
data class GetAttributesResponse(
  val id: String,
  @SerialName("user_id")
  val userId: String,
  @SerialName("attribute_key")
  val attributeKey: String,
  val value: String,
  @SerialName("original_id")
  val originalId: String
)

suspend fun getAttributes(client: KwilActionClient): List<GetAttributesResponse> {
  return client.callAction<GetAttributesResponse>("get_attributes", mapOf(
    
  ))
}

suspend fun editAttribute(client: KwilActionClient,
id: String,
attributeKey: String,
value: String): String? {
    return client.executeAction("edit_attribute", mapOf(
      "id" to id,
    "attribute_key" to attributeKey,
    "value" to value
    ), "Edit an existing attribute", true);
}

suspend fun removeAttribute(client: KwilActionClient,
id: String): String? {
    return client.executeAction("remove_attribute", mapOf(
      "id" to id
    ), "Remove an existing attribute", true);
}

suspend fun shareAttribute(client: KwilActionClient,
id: String,
originalAttributeId: String,
attributeKey: String,
value: String): String? {
    return client.executeAction("share_attribute", mapOf(
      "id" to id,
    "original_attribute_id" to originalAttributeId,
    "attribute_key" to attributeKey,
    "value" to value
    ), "Share an attribute", true);
}
//  WRITE GRANTS ACTIONS
//  Must be in yyyy-mm-ddThh:mm:ssZ format
//  Must be in yyyy-mm-ddThh:mm:ssZ format
//  Must be in yyyy-mm-ddThh:mm:ssZ format
//  Will fail if not in the yyyy-mm-ddThh:mm:ssZ format, and not comply to RFC3339
//  Check the format and precedence

@Serializable
data class DwgMessageResponse(
  val message: String
)

suspend fun dwgMessage(client: KwilActionClient,
ownerWalletIdentifier: String,
granteeWalletIdentifier: String,
issuerPublicKey: String,
id: String,
accessGrantTimelock: String,
notUsableBefore: String,
notUsableAfter: String): DwgMessageResponse {
  return client.callAction<DwgMessageResponse>("dwg_message", mapOf(
    "owner_wallet_identifier" to ownerWalletIdentifier,
    "grantee_wallet_identifier" to granteeWalletIdentifier,
    "issuer_public_key" to issuerPublicKey,
    "id" to id,
    "access_grant_timelock" to accessGrantTimelock,
    "not_usable_before" to notUsableBefore,
    "not_usable_after" to notUsableAfter
  )).first()
}
//  ACCESS GRANTS ACTIONS

suspend fun revokeAccessGrant(client: KwilActionClient,
id: String): String? {
    return client.executeAction("revoke_access_grant", mapOf(
      "id" to id
    ), "Revoke an Access Grant from idOS", true);
}

@Serializable
data class GetAccessGrantsOwnedResponse(
  val id: String,
  @SerialName("ag_owner_user_id")
  val agOwnerUserId: String,
  @SerialName("ag_grantee_wallet_identifier")
  val agGranteeWalletIdentifier: String,
  @SerialName("data_id")
  val dataId: String,
  @SerialName("locked_until")
  val lockedUntil: Int,
  @SerialName("content_hash")
  val contentHash: String,
  @SerialName("inserter_type")
  val inserterType: String,
  @SerialName("inserter_id")
  val inserterId: String
)

suspend fun getAccessGrantsOwned(client: KwilActionClient): List<GetAccessGrantsOwnedResponse> {
  return client.callAction<GetAccessGrantsOwnedResponse>("get_access_grants_owned", mapOf(
    
  ))
}
//  As arguments can be undefined (user can not send them at all), we have to have default values: page=1, size=20
//  Page number starts from 1, as UI usually shows to user in pagination element
//  Ordering is consistent because we use height as first ordering parameter

@Serializable
data class GetAccessGrantsGrantedResponse(
  val id: String,
  @SerialName("ag_owner_user_id")
  val agOwnerUserId: String,
  @SerialName("ag_grantee_wallet_identifier")
  val agGranteeWalletIdentifier: String,
  @SerialName("data_id")
  val dataId: String,
  @SerialName("locked_until")
  val lockedUntil: Int,
  @SerialName("content_hash")
  val contentHash: String,
  @SerialName("inserter_type")
  val inserterType: String,
  @SerialName("inserter_id")
  val inserterId: String
)

suspend fun getAccessGrantsGranted(client: KwilActionClient,
userId: String?,
page: Int,
size: Int): List<GetAccessGrantsGrantedResponse> {
  return client.callAction<GetAccessGrantsGrantedResponse>("get_access_grants_granted", mapOf(
    "user_id" to userId,
    "page" to page,
    "size" to size
  ))
}

@Serializable
data class GetAccessGrantsGrantedCountResponse(
  val count: Int
)

suspend fun getAccessGrantsGrantedCount(client: KwilActionClient,
userId: String?): GetAccessGrantsGrantedCountResponse {
  return client.callAction<GetAccessGrantsGrantedCountResponse>("get_access_grants_granted_count", mapOf(
    "user_id" to userId
  )).first()
}

@Serializable
data class HasLockedAccessGrantsResponse(
  val has: Boolean
)

suspend fun hasLockedAccessGrants(client: KwilActionClient,
id: String): HasLockedAccessGrantsResponse {
  return client.callAction<HasLockedAccessGrantsResponse>("has_locked_access_grants", mapOf(
    "id" to id
  )).first()
}

@Serializable
data class DagMessageResponse(
  val message: String
)

suspend fun dagMessage(client: KwilActionClient,
dagOwnerWalletIdentifier: String,
dagGranteeWalletIdentifier: String,
dagDataId: String,
dagLockedUntil: Int,
dagContentHash: String): DagMessageResponse {
  return client.callAction<DagMessageResponse>("dag_message", mapOf(
    "dag_owner_wallet_identifier" to dagOwnerWalletIdentifier,
    "dag_grantee_wallet_identifier" to dagGranteeWalletIdentifier,
    "dag_data_id" to dagDataId,
    "dag_locked_until" to dagLockedUntil,
    "dag_content_hash" to dagContentHash
  )).first()
}
//  Get the wallet type and public key for XRPL/NEAR wallets from database
//  This works for EVM-compatible signatures only

suspend fun createAgByDagForCopy(client: KwilActionClient,
dagOwnerWalletIdentifier: String,
dagGranteeWalletIdentifier: String,
dagDataId: String,
dagLockedUntil: Int,
dagContentHash: String,
dagSignature: String): String? {
    return client.executeAction("create_ag_by_dag_for_copy", mapOf(
      "dag_owner_wallet_identifier" to dagOwnerWalletIdentifier,
    "dag_grantee_wallet_identifier" to dagGranteeWalletIdentifier,
    "dag_data_id" to dagDataId,
    "dag_locked_until" to dagLockedUntil,
    "dag_content_hash" to dagContentHash,
    "dag_signature" to dagSignature
    ), "Create an Access Grant in idOS", true);
}
//  data_id is an id of a copy. It always has a user. So if no user found then there is no credential found.

suspend fun createAccessGrant(client: KwilActionClient,
granteeWalletIdentifier: String,
dataId: String,
lockedUntil: Int,
contentHash: String,
inserterType: String,
inserterId: String): String? {
    return client.executeAction("create_access_grant", mapOf(
      "grantee_wallet_identifier" to granteeWalletIdentifier,
    "data_id" to dataId,
    "locked_until" to lockedUntil,
    "content_hash" to contentHash,
    "inserter_type" to inserterType,
    "inserter_id" to inserterId
    ), "Create a new access grant", true);
}

@Serializable
data class GetAccessGrantsForCredentialResponse(
  val id: String,
  @SerialName("ag_owner_user_id")
  val agOwnerUserId: String,
  @SerialName("ag_grantee_wallet_identifier")
  val agGranteeWalletIdentifier: String,
  @SerialName("data_id")
  val dataId: String,
  @SerialName("locked_until")
  val lockedUntil: Int,
  @SerialName("content_hash")
  val contentHash: String,
  @SerialName("inserter_type")
  val inserterType: String,
  @SerialName("inserter_id")
  val inserterId: String
)

suspend fun getAccessGrantsForCredential(client: KwilActionClient,
credentialId: String): List<GetAccessGrantsForCredentialResponse> {
  return client.callAction<GetAccessGrantsForCredentialResponse>("get_access_grants_for_credential", mapOf(
    "credential_id" to credentialId
  ))
}
//  OTHER ACTIONS
//  Should we improve it to work with near wallets too?

@Serializable
data class HasProfileResponse(
  @SerialName("has_profile")
  val hasProfile: Boolean
)

suspend fun hasProfile(client: KwilActionClient,
address: String): HasProfileResponse {
  return client.callAction<HasProfileResponse>("has_profile", mapOf(
    "address" to address
  )).first()
}
//  PASSPORTING CLUB ACTIONS

suspend fun addPassportingClubAsOwner(client: KwilActionClient,
id: String,
name: String): String? {
    return client.executeAction("add_passporting_club_as_owner", mapOf(
      "id" to id,
    "name" to name
    ), "Add a new passporting club as owner", true);
}

suspend fun deletePassportingClubAsOwner(client: KwilActionClient,
id: String): String? {
    return client.executeAction("delete_passporting_club_as_owner", mapOf(
      "id" to id
    ), "Delete a passporting club as owner", true);
}

suspend fun addPassportingPeerAsOwner(client: KwilActionClient,
id: String,
name: String,
issuerPublicKey: String,
passportingServerUrlBase: String): String? {
    return client.executeAction("add_passporting_peer_as_owner", mapOf(
      "id" to id,
    "name" to name,
    "issuer_public_key" to issuerPublicKey,
    "passporting_server_url_base" to passportingServerUrlBase
    ), "Update a passporting peer as owner", true);
}

suspend fun deletePassportingPeerAsOwner(client: KwilActionClient,
id: String): String? {
    return client.executeAction("delete_passporting_peer_as_owner", mapOf(
      "id" to id
    ), "Delete a passporting peer as owner", true);
}

suspend fun updatePassportingPeerAsOwner(client: KwilActionClient,
id: String,
name: String,
issuerPublicKey: String,
passportingServerUrlBase: String): String? {
    return client.executeAction("update_passporting_peer_as_owner", mapOf(
      "id" to id,
    "name" to name,
    "issuer_public_key" to issuerPublicKey,
    "passporting_server_url_base" to passportingServerUrlBase
    ), "Update a passporting peer as owner", true);
}

suspend fun addPeerToClubAsOwner(client: KwilActionClient,
passportingClubId: String,
passportingPeerId: String): String? {
    return client.executeAction("add_peer_to_club_as_owner", mapOf(
      "passporting_club_id" to passportingClubId,
    "passporting_peer_id" to passportingPeerId
    ), "Add a peer to a passporting club as owner", true);
}

suspend fun deletePeerFromClubAsOwner(client: KwilActionClient,
passportingClubId: String,
passportingPeerId: String): String? {
    return client.executeAction("delete_peer_from_club_as_owner", mapOf(
      "passporting_club_id" to passportingClubId,
    "passporting_peer_id" to passportingPeerId
    ), "Delete a peer from a passporting club as owner", true);
}
//  get clubs the peer belongs to

@Serializable
data class GetPassportingPeersResponse(
  val id: String,
  val name: String,
  @SerialName("issuer_public_key")
  val issuerPublicKey: String,
  @SerialName("passporting_server_url_base")
  val passportingServerUrlBase: String,
  @SerialName("club_id")
  val clubId: String,
  @SerialName("club_name")
  val clubName: String
)

suspend fun getPassportingPeers(client: KwilActionClient): List<GetPassportingPeersResponse> {
  return client.callAction<GetPassportingPeersResponse>("get_passporting_peers", mapOf(
    
  ))
}
